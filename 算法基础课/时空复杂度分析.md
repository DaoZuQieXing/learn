#### 时空复杂度分析

-----------------

##### 由数据范围反推算法复杂度以及算法内容

感谢分享 [$yxc$](https://www.acwing.com/blog/content/32/)

一般 $ACM$ 或者笔试题的时间限制是 $1$ 秒或 $2$ 秒

在这种情况下，$c++$ 代码中的操作次数控制在 $10^7$ ~ $10^8$为最佳

下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：

- $n \le 30$，指数级别：$Dfs$ +剪枝，状态压缩 $Dp$
- $n \le 100$，$O(n^3)$：$Floyd$，$Dp$，高斯消元
- $n \le 1000$，$O(n^2)$，$O(n^2logn)$：$Dp$，二分，朴素版 $Dijkstra$，朴素版 $Prim$，$Bellman-Ford$
- $n \le 10000$，$O(n * \sqrt{n})$：块状链表，分块，莫队
- $n \le 100000$，$O(nlogn)$：各种 $Sort$，线段树，树状数组，$Set/Map$，$Heap$，拓扑排序，$Dijkstra+heap$，$Prim+heap$，$Kruskal$，$Spfa$，求凸包，求半平面交，二分，$CDQ$ 分治，整体二分，后缀数组，树链剖分，动态树
- $n \le 1000000$，$O(n)$，以及常数较小的 $O(nlogn)$ 算法：单调队列，$Hash$，双指针扫描，并查集，$KMP$，$AC$ 自动机，常数比较小的 $O(nlogn)$ 的算法：$Sort$，树状数组，$heap$，$Dijkstra$，$Spfa$
- $n \le 10000000$，$O(n)$：双指针扫描，$KMP$，$AC$ 自动机，线性筛素数
- $n \le 10^9$，$O(\sqrt{n})$：判断质数
- $n \le 10^{18}$，$O(logn)$，最大公约数，快速幂，数位 $Dp$
- $n \le 10^{1000}$，$O((logn)^2)$，高精度加减乘除
- $n \le 10^{100000}$，$O(logk*loglogk)$，$k$ 表示位数：高精度加减，FFT/NTT

---------------------

##### 分析代码复杂度

:star2:小技巧：实际会右边会大一些
$$
\log_210^x \approx 3 * x
$$


- 看循环

  一维前缀和算法，含有两个循环，一个循环 $n$ 次，一个循环  $m$ 次，**时间复杂度为 $O(n + m)$。**

  二维前缀和算法，含有两重循环，**时间复杂度为 $O(n^2)$。**

- 递归

  **看递归函数执行多少次（形象成递归搜索树就是多少层），然后看函数内部的执行情况**

  快速排序，平均意义上有 $logn$ 层，每层 $O(n)$，因此**时间复杂度为 $O(nlogn)$。**

  归并排序，实际上有 $logn$ 层，每层 $O(n)$，因此**时间复杂度为 $O(n)$。**

  二分，每次都将区间对半分，因此**时间复杂度为 $O(logn)$。**

- 双指针算法

  看似有两重循环，但是内层循环只增不减，内层循环的执行次数一定是小于等于 $n$ 的，所以**其时间复杂度为 $O(n)$。**

  单调栈类似，每个元素最多只会进栈一次，因此最多也只会出栈一次，所以内层循环只会执行 $n$ 次，所以其**时间复杂度为 $O(n)$** 

  单调队列也是类似，每个元素最多只会进队一次，因此也最多只会出队一次，内层循环只会执行 $n$ 次，所以其**时间复杂度为 $O(n)$**

  KMP，$i$ 每增加 $1$ ，$j$ 最多增加 $1$，因此 $j$ 最多增加 $n$，内层循环每执行一次，$j$ 起码减一，减到 $0$ 为止，因此内层循环最多执行 $n$ 次，则其**时间复杂度为 $O(n)$。**

- 并查集

  加上路径压缩优化，其**时间复杂度是 $O(nlogn)$，**再加上按秩合并，其时间复杂度是 $O(loglogn)$。

- 堆

  取得最小值，$O(1)$

  堆的各种操作依赖 $up$ 操作或 $down$ 操作，这两种操作最坏情况下从堆底走到堆顶（或者从堆顶走到堆底），因此这两种操作的时间复杂度与树的高度有关，由于堆是一颗完全二叉树，所以堆的高度是 $logn$ 的，则**堆的操作的时间复杂度即 $O(logn)$**

- 哈希表

  平均意义上增删改查的效率都是 $O(1)$ 

- DFS和BFS

  可以将执行过程转换成递归搜索树来研究其时间复杂度

- 图的遍历

  深度优先遍历和宽度优先遍历，每个点遍历一次需要 $n$，还会遍历每个点的所有边（也就是遍历所有边）$m$，因此两者的时间复杂度是 $O(n + m)$

  拓扑排序基于宽度优先遍历，所以时间复杂度为 $O(n + m)$

- Dijkstra算法

  朴素版本，两重循环，时间复杂度为 $O(n^2)$

  堆优化版，$for$ 循环只会执行 $m$ 次，每次插入的效率是 $O(logm)$， 所以时间复杂度为 $O(mlogm)$

- Bellman-frod算法

  一层循环 $n$ 次，一层循环 $m$ 次，因此时间复杂度是 $O(n*m)$ 次

- Spfa算法

  最坏情况下 $O(n * m)$

- Floyd算法

  $O(n^3)$

- Prim算法

  $O(n^2)$

- kruskal算法

  排序 $mlogm$，后面 $for$ 循环 $O(m)$ 级别的，因此整个的效率是 $mlogm$，时间复杂度为 $O(mlogm)$

- 染色法判定二分图

  其实是图的深度优先遍历或者宽度优先遍历，因此时间复杂度为 $O(n + m)$

- 匈牙利算法

  对每一个点循环一次，需要 $O(n)$ 的时间，每次判断（find函数）的时候，会遍历所有点的所有边，因此循环内需要 $O(n * m)$，又因为 $m$ 最坏是 $n$ 级别，所以匈牙利算法的最坏情况的时间复杂度是 $O(n^3)$，实际运行效率很快

- 试除法

  从 $2$ 循环到 $\sqrt{x}$，因此其时间复杂度为 $O(\sqrt{x})$

  分解质因数相同

- 筛素数

  埃氏筛法：时间复杂度为 $O(nlogn)$，如果直接忽视合数的话，时间复杂度是 $O(nlognlogn)$ 

- 辗转相除法

  时间复杂度为 $O(logn)$

- 快速幂

  时间复杂度为 $O(logk)$

- 最长上升子序列Ⅱ

  外层循环 $n$ 次，内层循环 $logn$ 次，则时间复杂度为 $O(nlogn)$

- 动态规划

  - 看循环层数

  - 状态数量 * 状态转移的计算量

- 树形Dp

  没有上司的舞会，边有多少，就会循环多少次
  
- 记忆化搜索

  滑雪，状态数量（$n^2$ ）乘以状态转移的计算量（$O(1)$）

- 贪心

  一般是排序＋循环

----------------------

##### 空间复杂度分析

**$64MB$ 可以开多少个 $int$ 变量呢？**

$64MB = 2^{26} Byte$

$int$ 变量的大小是 $4 Byte$

因此可以开 $2^{26} / 2^2 = 2^{24}$ 个，也就是 $16000000$ 个

$c++$ 可以通过 $sizeof$ 函数（单位是字节）计算

**关于递归**

递归多少层，需要的空间就是多少，比如快排 $logn$ 层，就额外（除了数组开的空间）用了 $O(logn)$

